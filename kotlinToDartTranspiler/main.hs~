module Transpiler where

import Data.Char
import Data.List
import Control.Monad
import Control.Applicative
import Debug.Trace

alpha :: String
alpha = ['a'..'z'] ++ ['A'..'Z'] ++ ["_"]

digit :: String
digit = ['0' .. '9']

tokenize :: String -> [String]
tokenize [] = []
tokenize xxs@(c : cs)
  | c == '-' && head cs == '>' = "->" : tokenize (tail cs)
  | c `elem` "(){}," = [c] : tokenize cs
  | not (null s) = s : tokenize ss
  | otherwise = tokenize cs
  where
    (s, ss) = span (`elem` alpha ++ digit) xxs

isName :: String -> Bool
isName "" = False
isName (c:cs) = elem c alpha && all (`elem` alpha ++ digit) cs  

-----------------------------------------------------
-------------- your parser combinator ---------------
-----------------------------------------------------

newtype Parser val = Parser { parse :: String -> [(val, String)]  }

parseCode :: Parser a -> String -> Either String a
parseCode m s = case parse m s of
  [(res, [])] -> Right res
  _           -> Left "Hugh?"
--


-- TODO: Make Node datatypes correct
data Fun  = Fun exp params lambda 
data Name = Nam String
data Lambda = Lam params stmts

-- TODO: make a parser for each Node
nameParser :: Parser Name 
nameParser = Parser parser
  where
    parser input = if isName name then [(Nam name, rest)] else [] 
      where
        (name:rest) = tokenize input

lambdaParser :: Parser Lambda
lambdaParser = Parser (\_ -> [])
  
expressionParser input = (parse $ nameParser input) ++ (parse $ lambdaParser input)
        
-- TODO: Each parser calls other parsers and finally parse Code calls the functionParser
-- TODO: In the end we have an ast which can be transpiled easily
-- TODO: When a parser returns an empty string we consider it failed
-- TODO: Parse or parseOr [Parser a] -> String -> [(a, String)] This should be used to parse with order of precedence

(<~>) :: Alternative a => a b -> a b -> a b
(<~>) = flip (<|>)

-- the code given above is not necessary
-- but they might help
-- if you have your own idea you can simply remove all of them :D

transpile :: String -> Either String String
transpile input = trace (intercalate "|" $ tokenize input) (Right "")

